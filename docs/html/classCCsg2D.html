<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>MarSTDv2004: CCsg2D Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.1 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>CCsg2D Class Reference</h1><a href="classCCsg2D-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
The 2D CSG routines are used to add, subtract and intersect 2D geometry, as in polygons. The algoritm makes no assumptions about in which planes the polygons lie. They could even be in different planes, however this would yield incorrect results. One should make sure geometry lies in the same plane - any plane - and everything will work well. Also, one should note CSG operations are only available for convex polygons. Should you wish to use concave object, please deconstruct your geometry first into convex parts and perform the CSG operation on each part seperately. <div class="fragment"><pre class="fragment"><span class="comment">// Example:</span>

<span class="keywordtype">void</span> make_shape(<a class="code" href="classCMesh.html">CMesh</a>&amp; mesh)
{

        Poly poly1; <span class="comment">// poly1 and poly2 will be added together.</span>
        Poly poly2;
        Poly poly3; <span class="comment">// After poly1 and poly2 are added, poly3 will be subtracted.</span>
        
        <span class="comment">// my_make_square(CPoly&amp; poly, CVector origin, float size) is a custom function used to create a square with sides length size and centered at origin.</span>
        
        my_make_square(poly1, <a class="code" href="classCVector.html">CVector</a>(-1.0, -1.0, 0.0), 2.0);
        my_make_square(poly2, <a class="code" href="classCVector.html">CVector</a>(+1.0, +1.0, 0.0), 2.0);
        my_make_square(poly3, <a class="code" href="classCVector.html">CVector</a>( 0.0,  0.0, 0.0), 1.0);   
        
        <span class="comment">// Make sure the mesh is clear.</span>
         
        mesh.clear();
        
        <span class="comment">// Addition may yield more than one polygon. So we need a mesh to temporarily store the intermediate result, before we subtract poly3.</span>

        <a class="code" href="classCMesh.html">CMesh</a> temp;
        
        <a class="code" href="classCCsg2D.html#CCsg2De0">CCsg2D::I</a>().<a class="code" href="classCCsg2D.html#CCsg2Da1">addition</a>(&amp;poly1, &amp;poly2, &amp;temp);

        <span class="comment">// Subtract poly3 from the intermediate results stored in temp. This is done by for every polygon in temp, calculating the subtraction of poly3.</span>
        
        <span class="keywordflow">for</span> (<a class="code" href="classCPoly.html">CPoly</a>* poly = temp.<a class="code" href="classCMesh.html#CMesho0">polyHead</a>; poly; poly = poly-&gt;<a class="code" href="classCPoly.html#CPolyo7">next</a>)
                <a class="code" href="classCCsg2D.html">CCsg2D</a>::I().subtraction(poly, &amp;poly3, &amp;mesh);
        
}
</pre></div> 
<p>

<p>
Definition at line <a class="el" href="CCsg2D_8h-source.html#l00066">66</a> of file <a class="el" href="CCsg2D_8h-source.html">CCsg2D.h</a>.<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="CCsg2Da1" doxytag="CCsg2D::addition"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCsg2D.html#CCsg2Da1">addition</a> (<a class="el" href="classCPoly.html">CPoly</a> *poly1, <a class="el" href="classCPoly.html">CPoly</a> *poly2, <a class="el" href="classCMesh.html">CMesh</a> *out)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add two polygons together and store the result in out. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="CCsg2Da2" doxytag="CCsg2D::subtraction"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCsg2D.html#CCsg2Da2">subtraction</a> (<a class="el" href="classCPoly.html">CPoly</a> *poly1, <a class="el" href="classCPoly.html">CPoly</a> *poly2, <a class="el" href="classCMesh.html">CMesh</a> *out)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subtract poly2 from poly1, and store the result in out. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="CCsg2Da3" doxytag="CCsg2D::intersection"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCsg2D.html#CCsg2Da3">intersection</a> (<a class="el" href="classCPoly.html">CPoly</a> *poly1, <a class="el" href="classCPoly.html">CPoly</a> *poly2, <a class="el" href="classCPoly.html">CPoly</a> *out)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the intersection (overlapping area) of poly1 and poly2, and store the result in out. Note this function stored it's result in a polygon rather than a mesh, because the intersection of 2 convex polygon can never yield more than 1 (convex) polygon. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="CCsg2Da4" doxytag="CCsg2D::exclusiveor"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCsg2D.html#CCsg2Da4">exclusiveor</a> (<a class="el" href="classCPoly.html">CPoly</a> *poly1, <a class="el" href="classCPoly.html">CPoly</a> *poly2, <a class="el" href="classCMesh.html">CMesh</a> *out)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the inverse of the intersection, and store the result in out. <br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classCCsg2D.html">CCsg2D</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCsg2D.html#CCsg2De0">I</a> ()</td></tr>

</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="CCsg2De0" doxytag="CCsg2D::I"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">static <a class="el" href="classCCsg2D.html">CCsg2D</a>&amp; CCsg2D::I           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Use this function to get a reference to the 2d csg singleton object. 
<p>
Definition at line <a class="el" href="CCsg2D_8h-source.html#l00082">82</a> of file <a class="el" href="CCsg2D_8h-source.html">CCsg2D.h</a>.    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="CCsg2D_8h-source.html">CCsg2D.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Tue Feb 8 21:59:34 2005 for MarSTDv2004 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.1 </small></address>
</body>
</html>
